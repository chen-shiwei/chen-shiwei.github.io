# go 是使用自动内存管理

随着用户程序申请内存越来越多，系统的垃圾越来越多，当达到一定的阈值，需要清理垃圾，保证程序正常运行。

## 常见的垃圾回收算法

- 标记清除

  分为两阶段

  - 标记 marking 从根对象出发查找并标记堆中所有存活的对象
  - 清除 sweep 遍历堆中的所有对象，回收未被标记的垃圾对象并将回收的内存加入到空闲链表中(方便后续使用 **空闲链表分配器**)

> 整个标记清除过程中用户程序无法执行，所以需要更复杂的机制解决STW。

## 三色标记工作原理

> 三色可以缩短stw时间

- 白色 垃圾，可能会被收集器回收
- 黑色 根对象可达对象和不存在引用外部指针的的对象
- 灰色 黑色对象引用的子对象

垃圾收集器开始工作时：

1. 跟对象可达都标记为灰色，放到灰色集合中

2. 取出一个灰色标记为黑色，该对象可达的所有对象标记为灰色
3. 重复取出灰色继续扫描，直到不存在灰色对象

此时只有黑色和白色，白色为待回收垃圾。

> 在标记过程中，用户程序可能会修改对象的指针，导致在标记过程中出现引用的对象被回收。这需要引用屏障技术

## 屏障

> 一种屏障指令，让cpu和编译器在执行内存相关操作时遵守特定的约束。
>
> **增量和并发两种方式都可以与用户程序交替运行，使用屏障技术**保证垃圾收集的正确性



## 三色标记写屏障约束

- 在并发和增量标记的算法中保证三色不变性
  - 强三色不变性 黑色对象不会直接指向白色对象，只会指向灰色或黑色对象
  - 弱三色不变性 黑色指向白色对象是必须(由一条从灰色对象经由多个白色对象的可达路径)
    - 当有灰色对象已经指向白色对象时，可以直接白色对象
  - ![strong-weak-tricolor-invariant](https://img.draveness.me/2020-03-16-15843705141834-strong-weak-tricolor-invariant.png)

> 黑白不能直接指向，只能间接。

- 读屏障
  - 需要在读操作中加入代码片段，对用户程序性能影响大，一般采用写屏障保证三色不变性
- 写屏障
  - **Dijkstra 插入写屏障**
    - 将**有存活可能的对象都标记成灰色**
  - **Yuasa 删除写屏障**

## 增量收集器

减少程序最长暂停时间的一种方案，将原本较长暂停的时间切分成多个更小的GC时间片

需要在垃圾收集前开启屏障，当用户程序修改对象指针是经过屏障处理的。

## 并发收集器

不仅能减少程序的最长暂停时间，也能减少整个垃圾回收的时间。

写屏障+多核优势与用户程序并行执行。

## go语言垃圾收集阶段执行周期

- 清理终止阶段
  - 暂停程序
  - 
- 标记阶段
- 标记终止阶段
  - 暂停程序
- 清理阶段