---
title: "数据密集型应用设计"
date: "2021-03-09"
tag: ["数据密集型应用设计","book"]
categories: ["数据密集型应用设计","book"]
draft: true
---
# 第七章 事务

# 1.为什么需要事务

- 网络、应用程序、软件硬件会在任意时刻崩溃。
- 并发、数据竞争

>事务是应用程序将多个读写操作组合成一个逻辑单元的一种方式

# 2. ACID Atomicity、Consistency、Isolation、Durability

- Atomicity
  - 事务是原子性不可切分
- Consistency
  - **对数据的一组特定约束必须始终成立**
  - 事务执行账户A减少必须B对应增加，账户整体上必须借贷相抵
- Isolation
  - 同时执行的事务是隔离的
- Durability
  - 事务执行完成，写入数据不会丢失

**一个事务读取另一个事务的未被执行的写入（“脏读”）。**

## 2.1为什么需要弱隔离级别？

当两个事务不触及相同数据时，可以安全的并发运行，两者不依赖另一个。

当修改同一数据时，会出现并发问题，数据库通过事务隔离解决

- 可序列化 
  
- 串行执行，性能损失
  
- **不可串行化(弱隔离级别)**

  - 读未提交
    - 防止脏写
    - 不防止**脏读**(一个事务为提交或者终止，另一个事务可以看到未提交的数据)
    
  - 读已提交(最基本的事务隔离级别)
    - 只能看到已提交的数据(没有藏读)
    - 只会覆盖已经写入的数据(没有脏写)
    - 行锁(row-level lock)防止脏写，修改对象时，必须先获得锁
    - ![img](/Users/fotoable/GolandProjects/github.com/chen-shiwei.github.io/content/post/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E8%AE%BE%E8%AE%A1/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1-%E7%AC%AC%E4%B8%83%E7%AB%A0%E4%BA%8B%E5%8A%A1.assets/fig7-4.png)
  - **但行级锁会阻塞读请求，不能访问数据，所以对修改前数据进行快照，让读取求去从快照获取数据**
    
  - 快照隔离和可重复读

    - 可重复读

      - 可重复读指的是同一行在同一个事务下无论怎么读取都是同一个结果

    - 数据库必须可能保留一个对象的几个不同的提交版本，因为各种正在进行的事务可能需要看到数据库在不同的时间点的状态。因为它并排维护着多个版本的对象，所以这种技术被称为**多版本并发控制**

    - **使用多版本对象实现快照隔离**

      - 表中的每一行都有一个 `created_by` 字段，其中包含将该行插入到表中的的事务ID
      - 每行都有一个 `deleted_by` 字段，最初是空的。如果某个事务删除了一行，那么该行实际上并未从数据库中删除，而是通过将 `deleted_by` 字段设置为请求删除的事务的ID来标记为删除
      - 在稍后的时间，当确定没有事务可以再访问已删除的数据时，数据库中的垃圾收集过程会将所有带有删除标记的行移除，并释放其空间

    - #### 观察一致性快照的可见性规则(可见一个对象)

      - 读事务开始时，创建该对象的事务已经提交。
      - 对象未被标记为删除，或如果被标记为删除，请求删除的事务在读事务开始时尚未提交。

    - #### 快照隔离影响索引

      - 一种选择是使索引简单地指向对象的所有版本
        - 并且需要索引查询来过滤掉当前事务不可见的任何对象版本
        - 当垃圾收集删除任何事务不再可见的旧对象版本时，相应的索引条目也可以被删除。
      - 使用仅追加的B树，每个写入事务（或一批事务）都会创建一颗新的B树，当创建时，从该特定树根生长的树就是数据库的一个一致性快照
        - 没必要根据事务ID过滤掉对象，因为后续写入不能修改现有的B树；它们只能创建新的树根。但这种方法也需要一个负责压缩和垃圾收集的后台进程。

    - #### 可重复读与命名混淆

      - 在Oracle中称为**可序列化（Serializable）\**的，***
      - ***在PostgreSQL和MySQL中称为\**可重复读（repeatable read）**【23】。

## 2.2 防止丢失更新

  如果应用从数据库中读取值，修改写回修改的值（读取-修改-写入序列），可能会发生丢失更新的问题。

  如果两个事务同时执行，则其中一个的修改可能会丢失，因为第二个写入的内容并没有包括第一个事务的修改（有时会说后面写入**狠揍（clobber）** 了前面的写入）这种模式发生在各种不同的情况下：

- 增加计数器或更新账户余额（需要读取当前值，计算新值并写回更新后的值）
- 在复杂值中进行本地修改：例如，将元素添加到JSON文档中的一个列表（需要解析文档，进行更改并写回修改的文档）
- 两个用户同时编辑wiki页面，每个用户通过将整个页面内容发送到服务器来保存其更改，覆写数据库中当前的任何内容。

解决：
- 原子写
```	
UPDATE counters SET value = value + 1 WHERE key = 'foo'; 
```
- #### 显式锁定
```
BEGIN TRANSACTION;
SELECT * FROM figures
WHERE name = 'robot' AND game_id = 222
FOR UPDATE;

-- 检查玩家的操作是否有效，然后更新先前SELECT返回棋子的位置。
UPDATE figures SET position = 'c4' WHERE id = 1234;
COMMIT;
```

- #### 比较并设置（CAS）compare and set

  > 但是，如果数据库允许`WHERE`子句从旧快照中读取，则此语句可能无法防止丢失更新，因为即使发生了另一个并发写入，`WHERE`条件也可能为真。在依赖数据库的CAS操作前要检查其是否安全。
```
-- 根据数据库的实现情况，这可能也可能不安全
UPDATE wiki_pages SET content = '新内容'
WHERE id = 1234 AND content = '旧内容';
```

## 2.3 冲突解决和复制

“[最后写入胜利（丢弃并发写入）](https://github.com/Vonng/ddia/blob/master/ch5.md#最后写入胜利（丢弃并发写入）)”中所述。不幸的是，LWW是许多复制数据库中的默认方案。