---
title: "数据密集型应用设计"
date: "2021-03-08"
tag: ["数据密集型应用设计","book"]
categories: ["数据密集型应用设计","book"]
draft: true
---
# 第五章 复制(数据同步)

## 1. 多台机器

l之间需要复制的原因 ?

- 让数据与用户在地理上更接近，**减少延迟**
- 即使系统的一部分出故障，系统也能使用，**高可用**
- 集群伸缩扩容，提高请求并发，**提高吞吐量**

## 2. 常见复制的方式?

- 单领导 single leader
- 多领导 multi leader
- 无领导 laderless

### 2.1 Leader

主库

### 2.2 Follower

- 只读副本 only read replicas
- 从库 slavee
- 备库
  - 热备 hot 能接受客户端请求的副本
  - 温备 warm 只追求领导者，不处理客户端请求
  - 冷备 cold 

### 2.3 同步复制与异步复制

- 半同步复制
  - 两个从节点，一个节点同步，另一个异步
- 链式复制
- 异步复制

### 2.4 添加新从库

全量快照snapshot+增量同步(binglog、aof)

### 2.5 节点宕机

- 监控报警、
- 故障切换、
- 主从替换、
- 哨兵机制

### 2.6 复制日志的实现

- 基于语句复制(binglog)
- 预写式日志(WAL(write ahead log))
- 逻辑日志复制(直接复制变更的数据)
- 基于触发器(事件触发、部分复制)

## 3. 复制延迟

### 3.1 问题

- 读己之写

  - 用户自己修改的内容从主库读(例如修改自己用户资料从主库读，查看其它用户从从库)
  - 客户端记录修改时间、判断内容是否最新，不够新切换数据读取(需要依赖时钟同步)
  - 如果用户多设备(手机、平板)需要保持都连接同一主库

- 单调读Monotonic reads(**用户首先从新副本读取，然后从旧副本读取。时光倒流。为了防止这种异常，我们需要单调的读取**)

  - 确保用户总是从同一副本读取 (根据用户id散列副本，而不是随机选择副本，但如果查询失败，再切换其他副本)

- 一致前缀读

  ```
  第三个复制延迟例子违反了因果律。 想象一下Poons先生和Cake夫人之间的以下简短对话：
  
  Mr. Poons​ Mrs. Cake，你能看到多远的未来？
  
  Mrs. Cake​ 通常约十秒钟，Mr. Poons.
  
  这两句话之间有因果关系：Cake夫人听到了Poons先生的问题并回答了这个问题。
  
  ​ 现在，想象第三个人正在通过从库来听这个对话。 Cake夫人说的内容是从一个延迟很低的从库读取的，但Poons先生所说的内容，从库的延迟要大的多（见图5-5）。 于是，这个观察者会听到以下内容：
  
  Mrs. Cake​ 通常约十秒钟，Mr. Poons.
  
  Mr. Poons​ Mrs. Cake，你能看到多远的未来？
  ```

  如果写入按某个顺序发生，那么读取也必须以同样的方式。

### 3.2 复制延迟解决方案

- 通过主库进行某种读取

### 3.3 多主复制

应用场景

- 运维多个数据中心(容忍单点故障，地理上更接近用户)，一个主库一个数据中心
- 性能
- 容忍数据中心停机
- 容忍网络问题
- 需要离线操作的客户端
  - 应用设备断网需要继续工作
  - 每一个设备都是一个数据中心
  - CouchDB
- 协同编辑
  - Google Docs
  - 多领导复制加速协作，但是会有写入冲突

### 3.4 处理写入冲突

- 同步与异步检测冲突
  - 同步检测冲突只适合单主
  - (多主复制的主要优点)异步允许每个副本独立接受写入
- 避免冲突
  - 当用户编辑自己的数据时，保证用户的用户都路由同一数据中心，并使用该数据中心的领导进行读写
- 收敛至一致状态
  - 所有副本必须在所有变更完成时收敛至一个相同的最终值
  - 每个写入唯一id(id高(时间戳相关)具有优先级写入胜利
- 写时执行和读时执行
  - 预置冲突解决脚本
  - CouchDB

自动冲突解决

- 无冲突复制数据类型
  - 是可以由多个用户同时编辑的集合，映射，有序列表，计数器等的一系列数据结构，它们以合理的方式自动解决冲突
- 可合并持久数据结构
  - git 版本控制
- 可执行转换
  - 专为同时编辑项目的有序列表而设计的，例如构成文本文档的字符列表
  - Google Docs

### 3.5 多主复制拓扑

## 4 无主复制（客户端处理错误）

- 一些数据存储系统采用不同的方法，放弃主库的概念，并允许任何副本直接接受来自客户端的写入。
- AWS Dynamo、 Riak，Cassandra和Voldemort
- 读请求也被并行地发送到多个节点
- 客户端发现副本3具有陈旧值，并将新值写回到该副本
- 如果有n个副本，每个写入必须由w节点确认才能被认为是成功的，并且我们必须至少为每个读取查询r个节点。 （在我们的例子中，$n = 3，w = 2，r = 2$）。只要$w + r> n$，我们期望在读取时获得最新的值，因为r个读取中至少有一个节点是最新的。遵循这些r值，w值的读写称为**法定人数（quorum）**[^vii](https://github.com/Vonng/ddia/blob/master/有时候这种法定人数被称为严格的法定人数，相对"宽松的法定人数"而言（见"[宽松的法定人数与提示移交](#宽松的法定人数与提示移交)"）)的读和写【44】。你可以认为，r和w是有效读写所需的最低票数。
- 监视你的数据库是否返回最新的结果
- 检测并发写入
- 最后写入胜利(对其并发写入)
- 合并同时写入的值
- 版本向量：当读取值时，版本向量会从数据库副本发送到客户端，并且随后写入值时需要将其发送回数据库。（Riak将版本向量编码为一个字符串，它称为**因果上下文（causal context）**）。版本向量允许数据库区分覆盖写入和并发写入