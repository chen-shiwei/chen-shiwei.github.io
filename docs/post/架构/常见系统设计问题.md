## 1. 分布式ID生成器

### 1.1 应用场景

- user_id
- 微博id
- msg_id
- 帖子id
- order_id

### 1.2 需求

- 全局唯一
- 短，节省内存
- 按时间粗略有序/按时间递增
- 具有标识性，易用

## 1.3 思路

- 基于数据库生成 

  - mysql 5.6 auto_increment 特性
  - postgres 9.6 sequence 特性
  - Flickr Ticket Servers

- 基于分布式协调器生成

  - etcd 强一致性 raft 协议
  - zookeeper paxos 协议
  - consule gossip 协议

  > 基于一个累计值(计数器)在一致性集群中。

- 划分命名空间并行生成

  - MongoDB objectID
  - snowflake 

### 1.4方案

1. UUID

   MongoDB 3.3 的objectid （12字节）生成规则：

   - 4个字节 unix_timestamp

     ```go
     func getTimestamp() int64 {
       return time.Now().Unix()
     }
     ```

   - 3字节机器id

   - 2字节进程id

   - 3字节计数器

   MongoDB 4.0

   - a 4-byte *timestamp value*, representing the ObjectId’s creation, measured in seconds since the Unix epoch 4位字节时间戳
   - a 5-byte *random value* 5字节随机数
   - a 3-byte *incrementing counter*, initialized to a random value 3字节计数器，初始值为一个随机器

2. snowflake 64字节 https://github.com/twitter-archive/snowflake/tree/snowflake-2010

   1. time - 41 bits (millisecond precision w/ a custom epoch gives us 69 years) 高位(字节序)时间戳 保证错略有序
   2. configured machine id - 10 bits - gives us up to 1024 machines 1024 机器id
   3. sequence number - 12 bits - rolls over every 4096 per machine (with protection to avoid rollover in the same ms) 12位序列号



相关技术文章

- [生成全局唯一ID的3个思路，来自一个资深架构师的总结](https://mp.weixin.qq.com/s?__biz=MzI4MTY5NTk4Ng==&mid=2247489561&idx=1&sn=7396f373af4efa62ba4dbecc6d7f83b3&source=41#wechat_redirect)
- https://github.com/twitter-archive/snowflake/tree/snowflake-2010

## 2. 短网址系统

### 2.1 应用场景

- 内容链接分享（会有字数限制）
- 短信内容携带链接

### 2.2 需求

​	尽可能短

### 2.3 设计

- 长度

  - 当前互联网网页总数为45亿， > 2^32  < 2^64，所以用64的整数足够了

  - 微博短网址长度为7的字符串，可以看做62进制的数
>长度不超过7的字符串，由大小写字母加数字共62个字母组成

- 一对一映射还是一对多映射？
  - 一对多
    - 可以收集 Http user-agent信息、用户名、所在网站做数据分析
- 如何计算短网址
  - uuid 生生成方案
- 如何存储
  - 短网址作为主键，长网址作为value
  - mysql、redis、LevelDB
- 跳转时301还是302？
  - 301 永久重定向，浏览器会存储跳转之后的地址不在请求短地址服务器，无法记录请求数据统计
  - 302 临时重定向

## 3. 信息流实现，微博、知乎首页、推特浏览
## 4. 限流器实现
## 5. 延迟队列(定时任务调度器)
- redis 有序集合 实现 参考 [有赞延迟队列设计](https://tech.youzan.com/queuing_delay/)
  - 任务携带执行时间戳当做score存储到ZSet，利用有序集合score根据时间戳从小到大排序排序
  - 然后ZRANGEBYSCORE 消费Zset 队列
  - 可以根据延迟任务的时间不同建立不同延迟队列，提高扫描速度，降低消息延迟
- 时间轮（HashedWheelTimer）循环队列
  - go实现 https://www.luozhiyun.com/archives/444
  - Linux 定时器实现也是这方案



>
>
> https://chai2010.cn/advanced-go-programming-book/ch6-cloud/readme.html

## 6. 线程安全 hashmap

- 锁分离
  - 读写锁分开 go map+lock
- sync.map TODO::待完善
  - 读写两个map，适合写少读多场景
  - 空间换时间，读map和写map 不同减少 互斥锁的影响

## 7. 访问频率最高的10个IP

## 8. 负载均衡设计

- 轮询

- 随机数取模机器数量

- hash 关键信息 比如user_id

## 9.KV存储引擎设计

> 要点：内存随机写甚至比磁盘顺序写要慢

- rockdb 由leveldb进化来得 
- LevelDB
#### 9.1 LevelDB 组成部分

  - SSTable 
    - MemTable(memory table)，新数据会写到这里，然后批量写入磁盘，以提高吞吐量
  - WAL 预写式日志(write Ahead Log) 
    - 写memory table 时会先写WAL日志，如果机器挂掉，内存中SSTable 丢失，可以通过WAL日志恢复数据
    - [通过WAL保证事务一支性](https://zhuanlan.zhihu.com/p/24900322)
  - Immtable MemTable(不变的内存表)
    - 当内存中的 MemTable达到指定大小后,不再接收数据，同时会有新的MemTable产生，新数据写到MemTable，老的MemTable随后会写到磁盘编程一个SST文件
  - SSTable 文件
    - 磁盘上的SSTable，文件尾部追加一块索引，记录key->offset，提交随机读的效率
    - SST文件为Level0到Level n多层，每一层多个SST文件
    - 单个SST文件容量随着层次增加成倍增长
    - Level 0 的SST文件 有Immtable MemTable 直接Dump产生，其他Level的SST文件由上一层的文件和本层文件归并产生
  - Manifest文件
    - Manifest 记录SST文件在不同Level 的分布、单个SST文件最大最小key、以及一些Level需要的元数据
  - Current 文件
    - Manifest可能有多个。Current记录Manifest文件名，让LevelDB启动时找到Manifest，进而加载Level多层的SST数据
    ![img](http://qt8wkgtri.hd-bkt.clouddn.com/blog/architecture.png)

#### 9.2 LevelDB 核心逻辑
1. SST文件尾部索引要放到内存中，这样索引就不需要一次IO了
2. 所有读先看MemTable，没有再查找内存中的索引(SST尾部索引放内存中)
3. 所有写操作都写MemTable，SST文件无法修改
4. 定期把MemTable写入磁盘，称为SST文件，并新建MemTable接收新数据
5. 定期对SST文件合并
6. SST不可修改的话，怎么更新和删除数据
	- 更新 追加新的key-value 到文件尾部，SST文件是从前往后读（写入时间最近往前读），新数据会被先读到
	- 删除 追加墓碑(tombstone)值，表示删除该key，在定期合并SST文件时丢弃这些key，既可以删除墓碑值

#### 9.3 Manifest文件

Manifest 记录SST 的层级、文件名、最小key 和最大key

![img](http://qt8wkgtri.hd-bkt.clouddn.com/blog/manifest.png)

#### 9.4 Log 文件

- 每个文件由多个block 组成，每个block 32k，读写以block 为单位
- 下图有3个block

<img src="http://qt8wkgtri.hd-bkt.clouddn.com/blog/log.png" alt="img" style="zoom:67%;" />

#### 9.5 SSTable

<img src="http://qt8wkgtri.hd-bkt.clouddn.com/blog/sstable.png" alt="img" style="zoom: 67%;" />

#### 9.6 MemTable

MemTable 数据是按key有序的，当插入数据时，需要把新key-val 插到合适的位置，保证key 的有序性；

MemTable底层数据结构是SkipTable。

#### 9.7 LevelDB 增删改查

- 增

  - 追加写入

- 删

  - 墓碑值

- 改

  - 追加写入

- 查

  - MemTable+SkipTable
  - key有序，BinarySearch
  - 页缓存
  - 布隆过滤器 bloom filter
  - 周期性分层合并

  

